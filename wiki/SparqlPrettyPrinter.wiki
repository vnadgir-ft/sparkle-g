#labels Featured,Phase-Design
#SPARKLE-G Pretty Printer and Syntactic Validator for SPARQL

==== Table of Content ====

<wiki:toc max_depth="3" />

= Introduction =

== SPARKLE-G ==

=== Pretty Printer and Syntactic Validator for the SPARQL 1.1 Query and Update Language ===

The sparkle-g project has released a pretty printer and syntactic validator for the [http://www.w3.org/TR/sparql11-query/ SPARQL 1.1 Query] and 
[http://www.w3.org/TR/2011/WD-sparql11-update-20110512/ Update Language] [http://www.w3.org/2001/sw/DataAccess/ http://sparkle-g.googlecode.com/svn/site/images/sw-sparql-green.png]. The pretty printer and syntactic validator is based on the [http://antlr.org/ ANTLR] framework for constructing recognizers, interpreters, compilers, and translators. The generation of the formatted output text relies on the [http://www.stringtemplate.org/ StringTemplate] template engine. [http://antlr.org/ ANTLR] and 
[http://www.stringtemplate.org/ StringTemplate] have both been crafted by [http://www.cs.usfca.edu/~parrt/ Terence Parr], a professor of computer science at the [http://www.cs.usfca.edu/ University of San Francisco].  

On developing the pretty printer emphasis had been placed on target language independence. Only a few Java constructs are embedded in the lexical and grammatical description of the [http://www.w3.org/TR/sparql11-query/ SPARQL 1.1 Query] and 
[http://www.w3.org/TR/2011/WD-sparql11-update-20110512/ Update Language]. Therefore it should be possible to generate the SPARQL pretty printer with only some small adaptions for a variety of [http://www.antlr.org/wiki/display/ANTLR3/Code+Generation+Targets target languages] in addition to Java, e.g. C, which are supported by [http://antlr.org/ ANTLR] and the [http://www.stringtemplate.org/ StringTemplate] template engine.


= Details =

== The Transformation Pipeline ==

Here a brief description of the transformation pipeline which every query is undergoing.

=== Conversion of Unicode Escape Sequences ===
  
The {{{UnicodePreprocessorFileStream}}} substitutes Unicode escape sequences (\uxxxx) by its UTF8 code.

The example SPARQL query has encoded the character S as Unicode escape sequence \u0053.

{{{
# $Id: kanji-02.rq,v 1.4 2005/11/06 08:27:50 eric Exp $
# test wide spaces
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX 食: <http://www.w3.org/kanji.ttl#>
\u0053ELECT ?name WHERE {
  [ foaf:name ?name ;
    食:食べる 食:海老 ] . }
}}}

After passing through the Unicode pre-processor the Unicode escape sequence is replaced by its UTF8 character code.

{{{
# $Id: kanji-02.rq,v 1.4 2005/11/06 08:27:50 eric Exp $
# test wide spaces
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX 食: <http://www.w3.org/kanji.ttl#>
SELECT ?name WHERE {
  [ foaf:name ?name ;
    食:食べる 食:海老 ] . }
}}}

=== Tokenizing of the SPARQL Query ===

The preprocessed query is passed on to the {{{SparqlLexer}}}. It splits the query into tokens which serve as input for the {{{SparqlParser}}}.

http://sparkle-g.googlecode.com/svn/site/images/SPP_1_Tokenizer.png

=== Parsing of the Query ===

The {{{SparqlParser}}} matches the query tokens delivered by the {{{SparqlLexer}}} against the SPARQL grammar defined by ANTLR rules. The Parse Tree below represents the sequence of rule invocations used to match the input query.

http://sparkle-g.googlecode.com/svn/site/images/SPP_2_ParseTree_Text.png

=== AST generation ===

The Abstract Syntax Tree is defined by adding rewrite rules to the parser grammar. The AST nodes below have been generated from the input query invoking the sequence of affected rewrite rules attached to the parser grammar rules.

http://sparkle-g.googlecode.com/svn/site/images/SPP_3_AST.png

=== Traversing the AST ===

The AST is input for the Tree Grammar. The imaginary UP and DOWN nodes have been added by ANTLR. The two graphics display the AST generated for the kanji input query.

http://sparkle-g.googlecode.com/svn/site/images/SPP_4_TreeWalker_Text1.png

http://sparkle-g.googlecode.com/svn/site/images/SPP_5_TreeWalker_Text2.png

=== Emitting the Formatted Query ===

The Tree Grammar rules have been augmented with {{{StringTemplate}}} rewrite rules. The template rewrites for the pretty printer are defined in the Ident.stg {{{StringTemplate}}} group file. Traversing the Tree Grammar rules invokes the referenced template. The generated formatted output of the kanji query is shown below.

{{{
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX 食: <http://www.w3.org/kanji.ttl#>

SELECT ?name
WHERE {
   [ foaf:name ?name;
   食:食べる 食:海老 ]
}
}}}

== How to Get the SPARQL Pretty Printer to Work ==

The transformation pipeline just described, now cast into Java statements:

{{{
    private String sparklegPrettyPrinter(String query) throws Exception {

        /* Path to StringTemplate Group File.
         * Location of ident.stg can/should be modified to your needs.
         * Fixed assignment just to keep all neccessary parts in one place.
         */
        String stringTemplate = "./src/main/antlr3/com/googlecode/sparkleg/ident.stg";

        /* transformation pipline
         * step 1: Unicode pre-processing
         * step 2: Lexical analysis
         */
        SparqlLexer lex = new SparqlLexer(new SparkleUnicodePreprocessorStringStream(query));
        CommonTokenStream tokens = new CommonTokenStream(lex);

        /* transformation pipline
         * step 3: build parse tree
         * step 4: generate AST
         */
        SparqlParser parser = new SparqlParser(tokens);
        SparqlParser.query_return r = parser.query();

        /* transformation pipline
         * step 5: read AST
         * step 6: traverse AST, pass parameters to stringTemplate and write output to string
         */
        CommonTreeNodeStream nodes = new CommonTreeNodeStream(r.getTree());
        SparqlT walker = new SparqlT(nodes);

        StringTemplateGroup g = new StringTemplateGroup(new FileReader(stringTemplate), AngleBracketTemplateLexer.class);
        walker.setTemplateLib(g);
        
        RuleReturnScope t = null;
        try {
            t = walker.query();
        } catch (RecognitionException e) {
            e.printStackTrace();
        }

        return t.toString();
    }
}}}
- to be continued -